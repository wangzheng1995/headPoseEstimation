import os
import numpy as np
from scipy import ndimage

'''guess the strange ordered list generated by os.walk dues to deep-order travelsal'''

def dense_to_one_hot(labels_dense, num_classes=5):
    '''Convert class labels from scalars to one-hot vectors.'''
    label_type = {'backwards':0, 'frontal_left':1, 'frontal_right':2, 'profile_left':3, 'profile_right':4}
    num_labels = labels_dense.shape[0]
    numeric_label = np.ones(num_labels, dtype='int32')
    i = 0
    for ld in labels_dense:
        numeric_label[i] = label_type[ld] 
        i = i+1
    index_offset = np.arange(num_labels) * num_classes
    labels_one_hot = np.zeros((num_labels, num_classes))
    labels_one_hot.flat[index_offset + numeric_label] = 1
    return labels_one_hot

def reshape_image(file_path):
    '''reshape the images into 4D uint numpy array [index, y, x, depth]'''
    print('Reshaping Image & Label', file_path)
    images = []
    labels = []
    i=0
    for root, dirnames, filenames in os.walk(file_path):
        for filename in filenames:
            filepath = os.path.join(root, filename)
            #print(filepath)
            image = ndimage.imread(filepath, flatten="True", mode="RGB")
            images.append(image)
            label = filename[:-4].split('-')[2]
            #print(label)
            labels.append(label)
    images = np.asarray(images)
    print(images.shape)
    labels = np.asarray(labels)
    print(labels.shape)
    perm = np.arange(images.shape[0])
    np.random.shuffle(perm)
    images = images[perm]
    labels = labels[perm]
    labels_one_hot = dense_to_one_hot(labels)
    return images, labels_one_hot

class DataSet(object):
    def __init__(self, images, labels, isConcate = False):
        assert images.shape[0] == labels.shape[0], (
        "images.shape: %s labels.shape: %s" % (images.shape,
                                                 labels.shape))
        self._num_examples = images.shape[0]
        
        # Convert shape from [num examples, rows, columns, depth] to [num examples, rows*columns] (assuming depth == 1)
        #assert images.shape[3] == 1
        images = images.reshape(images.shape[0], images.shape[1], images.shape[2], 1)
        
        # Convert from [0, 255] -> [0.0, 1.0].
        if isConcate==False:
            images = images.astype(np.float32)
            images = np.multiply(images, 1.0 / 255.0)
        
        self._images = images
        self._labels = labels
        self._epochs_completed = 0
        self._index_in_epoch = 0
        
    @property
    def images(self):
        return self._images
    @property
    def labels(self):
        return self._labels
    @property
    def num_examples(self):
        return self._num_examples
    @property
    def epochs_completed(self):
        return self._epochs_completed
    
    def next_batch(self, batch_size):
        '''Return the next `batch_size` examples from this data set.'''
        start = self._index_in_epoch
        self._index_in_epoch += batch_size
        if self._index_in_epoch > self._num_examples:
            #Finished epoch
            self._epochs_completed +=1
            #Shuffle the data
            perm = np.arange(self._num_examples)
            np.random.shuffle(perm)
            self._images = self._images[perm]
            self._labels = self._labels[perm]
            #Start next epoch
            start = 0
            self._index_in_epoch = batch_size
            assert batch_size <= self._num_examples
        end = self._index_in_epoch
        return start, end, self._images[start:end], self._labels[start:end]

def read_data_sets(file_path, size=0):
    raw_images, raw_labels_one_hot = reshape_image(file_path)
    if size != 0:
        images = raw_images[:size]
        labels_one_hot = raw_labels_one_hot[:size]
    else:
        images = raw_images
        labels_one_hot = raw_labels_one_hot
        
    return DataSet(images, labels_one_hot)
